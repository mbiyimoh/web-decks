// This is your Prisma schema file,
// learn more about it in the docs: https://pris.ly/d/prisma-schema

// Looking for ways to speed up your queries, or scale easily with your serverless or edge functions?
// Try Prisma Accelerate: https://pris.ly/cli/accelerate-init

generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider  = "postgresql"
  url       = env("DATABASE_URL")
  directUrl = env("DIRECT_URL") // Direct connection for migrations (port 5432)
}

// ============================================================================
// USER MANAGEMENT
// ============================================================================

model User {
  id String @id @default(cuid())

  // Auth linkage - the ID from NextAuth JWT (email for credentials, OAuth ID for Google)
  authId String @unique

  // Profile info - sourced from NextAuth session (authoritative)
  email String  @unique
  name  String?
  image String?

  // Classification
  userType UserType @default(TEAM_MEMBER)

  // Client portal linkage (nullable - only set for client users, future use)
  clientPortalId String? // e.g., "tradeblock", "plya", "wsbc"

  // Timestamps
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  // Relations
  clarityProfile     ClarityProfile?
  companionSynthesis CompanionSynthesis?
}

enum UserType {
  TEAM_MEMBER // @33strategies.ai email
  CLIENT // Linked to active client portal
  POTENTIAL_CLIENT // External user granted access via allowlist
}

// ============================================================================
// CLARITY CANVAS MODELS
// ============================================================================

model ClarityProfile {
  id String @id @default(cuid())

  // TRANSITION: Keep existing userId (authId) during migration
  userId String @unique // Legacy: stores authId directly

  // NEW: Add userRecordId to link to User table
  userRecordId String? @unique
  user         User?   @relation(fields: [userRecordId], references: [id], onDelete: Cascade)

  name String

  // NEW: Track whether full canvas structure has been seeded
  isCanvasInitialized Boolean @default(true) // true for existing profiles

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  sections      ProfileSection[]
  personas      Persona[]
  brainDumps    PersonaBrainDump[]
  inputSessions InputSession[]

  @@index([userId])
  @@index([userRecordId])
}

model ProfileSection {
  id        String  @id @default(cuid())
  profileId String
  key       String // "individual", "role", "organization", "goals", "network", "projects"
  name      String // Display name
  icon      String // Emoji icon
  order     Int // Display order (1-6)
  score     Int     @default(0) // 0-100 calculated score
  summary   String? // AI-generated summary

  subsections ProfileSubsection[]
  profile     ClarityProfile      @relation(fields: [profileId], references: [id], onDelete: Cascade)

  @@unique([profileId, key])
  @@index([profileId])
}

model ProfileSubsection {
  id        String  @id @default(cuid())
  sectionId String
  key       String // e.g., "background", "thinking_style"
  name      String // Display name
  order     Int // Display order within section
  score     Int     @default(0) // 0-100 calculated score
  summary   String? // AI-generated summary

  fields  ProfileField[]
  section ProfileSection @relation(fields: [sectionId], references: [id], onDelete: Cascade)

  @@unique([sectionId, key])
  @@index([sectionId])
}

model ProfileField {
  id           String @id @default(cuid())
  subsectionId String
  key          String // e.g., "career", "decision_making"
  name         String // Display name

  // Content
  summary     String? // Short display version (max ~100 chars)
  fullContext String? @db.Text // Complete captured context

  // Scoring
  score                Int     @default(0) // 0-100 completeness
  confidence           Float   @default(1.0) // 0-1 user-stated confidence
  flaggedForValidation Boolean @default(false) // User marked "not sure"

  // Synthesis tracking
  lastSynthesizedAt DateTime? // When synthesis last occurred
  synthesisVersion  Int       @default(0) // Increment on each synthesis

  // Temporal
  lastUpdated DateTime @default(now()) @updatedAt

  sources    FieldSource[]
  subsection ProfileSubsection @relation(fields: [subsectionId], references: [id], onDelete: Cascade)

  @@unique([subsectionId, key])
  @@index([subsectionId])
}

model FieldSource {
  id             String     @id @default(cuid())
  fieldId        String
  type           SourceType
  rawContent     String     @db.Text // Original input verbatim
  extractedAt    DateTime   @default(now())
  questionId     String? // If from interview question
  userConfidence Float      @default(1.0) // 0-1 user-stated at capture time

  // Link to parent input session (for archive traceability)
  inputSessionId String?
  inputSession   InputSession? @relation(fields: [inputSessionId], references: [id], onDelete: SetNull)

  field ProfileField @relation(fields: [fieldId], references: [id], onDelete: Cascade)

  @@index([fieldId])
  @@index([inputSessionId])
}

enum SourceType {
  VOICE
  TEXT
  QUESTION
}

// ============================================================================
// INPUT SESSION — Tracks complete raw inputs as submitted by user
// ============================================================================

model InputSession {
  id String @id @default(cuid())

  // Ownership (polymorphic - either Clarity Canvas or Central Command)
  clarityProfileId String?
  clarityProfile   ClarityProfile? @relation(fields: [clarityProfileId], references: [id], onDelete: Cascade)

  pipelineClientId String?
  pipelineClient   PipelineClient? @relation(fields: [pipelineClientId], references: [id], onDelete: Cascade)

  // Input details
  inputType   InputType
  title       String
  rawContent  String    @db.Text

  // Source metadata
  sourceModule  String  // "clarity-canvas", "central-command"
  sourceContext String? // e.g., "individual-pillar", "prospect-intake"

  // Voice-specific
  durationSeconds Int?

  // File-specific
  originalFileName String?

  // Processing results
  fieldsPopulated Int @default(0)

  // Timestamps
  capturedAt  DateTime  @default(now())
  processedAt DateTime?

  // Metadata (flexible for future needs)
  metadata Json @default("{}")

  // Relations
  fieldSources FieldSource[]

  @@index([clarityProfileId, capturedAt])
  @@index([pipelineClientId, capturedAt])
  @@index([sourceModule, capturedAt])
}

enum InputType {
  VOICE_TRANSCRIPT
  TEXT_INPUT
  FILE_UPLOAD
}

// ============================================================================
// CLARITY MODULES - Generic module infrastructure
// ============================================================================

model ClarityModule {
  id               String   @id @default(cuid())
  slug             String   @unique
  name             String
  description      String
  icon             String // Emoji or icon identifier
  estimatedMinutes Int
  enrichesSections String[] // Which profile sections this module enriches
  isActive         Boolean  @default(true)
  sortOrder        Int      @default(0)

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
}

// ============================================================================
// PERSONA SHARPENER - Module-specific models
// ============================================================================

model PersonaBrainDump {
  id        String         @id @default(cuid())
  profileId String
  profile   ClarityProfile @relation(fields: [profileId], references: [id], onDelete: Cascade)

  // Input
  inputType       String // "voice" | "text"
  rawTranscript   String  @db.Text
  audioBlobUrl    String? // S3/R2 URL if voice input
  durationSeconds Int? // Voice recording duration

  // Extraction Output (immutable snapshot)
  extractedData  Json // Full extraction response from GPT
  personaCount   Int // 1-3
  overallContext Json // { productDescription, marketContext, keyThemes }

  // Generated Questions (batch pre-generated per persona)
  customizedQuestions Json // { [personaId]: CustomizedQuestion[] }

  // Metadata
  createdAt    DateTime @default(now())
  processingMs Int? // Total extraction time in ms

  // Relations - personas created from this brain dump
  personas Persona[]

  @@index([profileId])
}

model Persona {
  id        String         @id @default(cuid())
  profileId String
  profile   ClarityProfile @relation(fields: [profileId], references: [id], onDelete: Cascade)

  // Link to brain dump (optional - manual personas won't have this)
  brainDumpId String?
  brainDump   PersonaBrainDump? @relation(fields: [brainDumpId], references: [id], onDelete: Cascade)

  // Extraction metadata (populated from brain dump if exists)
  extractionConfidence Float? // 0-1 overall confidence from extraction
  skippedQuestionIds   String[] // Questions auto-populated from brain dump

  name      String? // Auto-generated archetype name
  isPrimary Boolean @default(true)

  // Structured fields (JSON for flexibility)
  demographics Json? // { ageRange, lifestyle, techSavviness }
  jobs         Json? // { functional, emotional, social }
  goals        Json? // { priorities, successDefinition }
  frustrations Json? // { pastFailures, dealbreakers, currentWorkaround }
  behaviors    Json? // { decisionStyle, usageTime, timeAvailable, discoveryChannels, influences }
  antiPatterns String[]
  quote        String?

  // Computed scores (updated after each response)
  clarityOverall      Int @default(0)
  clarityIdentity     Int @default(0)
  clarityGoals        Int @default(0)
  clarityFrustrations Int @default(0)
  clarityEmotional    Int @default(0)
  clarityBehaviors    Int @default(0)

  // Tracking
  totalAssumptions Int @default(0)
  avgConfidence    Int @default(0)

  responses      Response[]
  sessions       SharpenerSession[]
  validationLink ValidationLink?

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([profileId])
  @@index([brainDumpId])
}

model Response {
  id        String           @id @default(cuid())
  personaId String
  persona   Persona          @relation(fields: [personaId], references: [id], onDelete: Cascade)

  // Mutually exclusive: either from founder session OR validation session
  sessionId           String?
  session             SharpenerSession?  @relation(fields: [sessionId], references: [id], onDelete: Cascade)
  validationSessionId String?
  validationSession   ValidationSession? @relation(fields: [validationSessionId], references: [id], onDelete: Cascade)

  questionId String // e.g., 'age-range', 'lifestyle'
  field      String // e.g., 'demographics.ageRange'

  // The answer
  value Json // Flexible: string, number, string[], object

  // Metadata
  isUnsure          Boolean @default(false)
  confidence        Int     @default(50) // 0-100
  additionalContext String?
  contextSource     String? // 'text' | null (voice deferred)

  // Tagging
  responseType   String // 'assumption'
  respondentId   String // User ID
  respondentRole String // 'founder'
  respondentName String?

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([personaId])
  @@index([sessionId])
  @@index([validationSessionId])
  @@index([questionId])
}

model SharpenerSession {
  id        String  @id @default(cuid())
  personaId String
  persona   Persona @relation(fields: [personaId], references: [id], onDelete: Cascade)

  sessionType String // 'sharpen'
  status      String @default("in_progress") // 'in_progress' | 'completed' | 'abandoned'

  // Progress tracking
  lastQuestionIndex Int @default(0)
  questionsAnswered Int @default(0)
  questionsSkipped  Int @default(0)
  questionsUnsure   Int @default(0)

  startedAt   DateTime  @default(now())
  completedAt DateTime?

  responses Response[]

  @@index([personaId])
}

// ============================================================================
// VALIDATION SHARING - External validation link system
// ============================================================================

model ValidationLink {
  id        String  @id @default(cuid())
  personaId String  @unique // One link per persona
  persona   Persona @relation(fields: [personaId], references: [id], onDelete: Cascade)

  slug     String  @unique // 16-char hex for public URL
  isActive Boolean @default(true)

  // Stats
  totalResponses Int @default(0)
  totalSessions  Int @default(0)

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  sessions ValidationSession[]

  @@index([slug])
}

model ValidationSession {
  id     String         @id @default(cuid())
  linkId String
  link   ValidationLink @relation(fields: [linkId], references: [id], onDelete: Cascade)

  // Optional respondent info (collected at end)
  respondentName  String?
  respondentEmail String?

  // Progress tracking
  status            String @default("in_progress") // 'in_progress' | 'completed' | 'abandoned'
  questionsAnswered Int    @default(0)
  questionsSkipped  Int    @default(0)

  startedAt   DateTime  @default(now())
  completedAt DateTime?

  responses Response[]

  @@index([linkId])
}

// ============================================================================
// CONTACT FORM SUBMISSIONS
// ============================================================================

model ContactSubmission {
  id String @id @default(cuid())

  // Contact info
  name  String
  email String

  // Interests (stored as array of IDs)
  interests String[]

  // Optional message
  message String? @db.Text

  // Tracking
  source String? // URL query param that led here (e.g., "m33t")

  // Status for manual follow-up
  status ContactStatus @default(NEW)
  notes  String?       @db.Text // Internal notes from team

  // Slack notification tracking
  slackNotificationSent  Boolean @default(false)
  slackNotificationError String? // Error message if notification failed

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([status])
  @@index([createdAt])
}

enum ContactStatus {
  NEW
  CONTACTED
  IN_PROGRESS
  CLOSED
}

// ============================================================================
// ARTIFACT SHARE LINKS - Password-protected sharing for portal artifacts
// ============================================================================

model ArtifactShareLink {
  id             String    @id @default(cuid())
  slug           String    @unique  // nanoid(21) - 126 bits entropy

  // What's being shared (composite unique - one link per artifact)
  clientId       String    // e.g., "tradeblock"
  artifactSlug   String    // e.g., "jan-2026-projections"

  // Security
  hashedPassword String    // bcrypt hash with work factor 10
  failedAttempts Int       @default(0)
  lockedUntil    DateTime?

  // Metadata
  accessCount    Int       @default(0)
  lastAccessedAt DateTime?
  createdAt      DateTime  @default(now())

  @@unique([clientId, artifactSlug])  // One link per artifact
  @@index([slug])
}

// ============================================================================
// CENTRAL COMMAND — Pipeline Management
// ============================================================================

model PipelineClient {
  id       String @id @default(cuid())
  name     String
  industry String?
  color    String  @default("#D4A84B")
  website  String?
  contactName     String?
  contactRole     String?
  contactEmail    String?
  contactPhone    String?
  contactLinkedin String?
  additionalContacts Json?
  notes            String? @db.Text
  notesVersions    Json?
  notesSource      String?
  enrichmentStatus   String   @default("pending")
  enrichmentLastRun  DateTime?
  enrichmentConfidence Json?
  enrichmentFindings   Json?
  enrichmentFindingsVersions Json?
  enrichmentSuggestedActions String[]
  rawInputText       String?  @db.Text
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
  pipelineRecord PipelineRecord?
  rubricFeedback RubricFeedback[]
  inputSessions  InputSession[]
}

model PipelineRecord {
  id       String @id @default(cuid())
  clientId String @unique
  client   PipelineClient @relation(fields: [clientId], references: [id], onDelete: Cascade)
  status   String @default("funnel")
  decision       String @default("pending")
  decisionReason String?
  currentStage  String  @default("lead")
  stageIndex    Int     @default(0)
  stageEnteredAt DateTime @default(now())
  stageHistory Json?
  value          Int?
  potentialValue Int?
  scoreStrategic  Int @default(5)
  scoreValue      Int @default(5)
  scoreReadiness  Int @default(5)
  scoreTimeline   Int @default(5)
  scoreBandwidth  Int @default(5)
  discoveryComplete  Boolean @default(false)
  assessmentComplete Boolean @default(false)
  readinessPercent   Int     @default(0)
  nextAction         String?
  nextActionVersions Json?
  nextActionSource   String?
  nextActionDate     DateTime?
  isNew        Boolean  @default(true)
  productFocus String?
  closedAt          DateTime?
  closedReason      String?
  closedReasonDetail String?
  lessonsLearned     String?  @db.Text
  lessonsVersions    Json?
  lessonsSource      String?
  reengageDate       DateTime?
  reengageNotes      String?  @db.Text
  reengageVersions   Json?
  reengageSource     String?
  intakeMethod String?
  intakeDate   DateTime?
  portalLink   String?
  clientStatus String @default("active")
  // Decision workflow fields
  decisionBucket   String?   // 'aggressive' | 'slow_burn' | 'back_burner' | 'explicit_no'
  nextStepNotes    String?   @db.Text
  decisionMadeAt   DateTime?
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
  @@index([status])
  @@index([currentStage])
}

model TeamCapacity {
  id          String @id @default(cuid())
  name        String
  role        String?
  color       String  @default("#3b82f6")
  utilization Int     @default(0)
  allocations Json @default("[]")
  updatedAt DateTime @updatedAt
}

// ============================================================================
// SCORING RUBRICS — Learning Loop for Score Calibration
// ============================================================================

model ScoringRubric {
  id          String   @id @default(cuid())
  dimension   String   // 'strategic' | 'value' | 'readiness' | 'timeline' | 'bandwidth'
  version     Int      @default(1)
  content     Json     // { description: string, indicators: { high: string[], medium: string[], low: string[] } }
  isActive    Boolean  @default(true)
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  // Link to feedback that triggered this version
  triggeringFeedbackId String?        @unique
  triggeringFeedback   RubricFeedback? @relation("TriggeringFeedback", fields: [triggeringFeedbackId], references: [id])

  @@unique([dimension, version])
  @@index([dimension, isActive])
}

model RubricFeedback {
  id              String   @id @default(cuid())
  dimension       String   // Which score dimension
  prospectId      String   // Which prospect triggered this
  originalScore   Int      // AI's original score
  adjustedScore   Int      // User's adjusted score
  feedback        String   @db.Text // User's natural language feedback
  createdAt       DateTime @default(now())

  // Link to rubric version this created (if any)
  createdRubric   ScoringRubric? @relation("TriggeringFeedback")

  // Reference to prospect
  prospect        PipelineClient @relation(fields: [prospectId], references: [id], onDelete: Cascade)

  @@index([dimension])
  @@index([prospectId])
}

// ============================================================================
// OAUTH 2.0 AUTHENTICATION — Database-backed credentials and OAuth provider
// ============================================================================

// Client credentials (replaces env var passwords)
model ClientCredential {
  id             String    @id @default(cuid())
  clientId       String    @unique  // e.g., "tradeblock"
  hashedPassword String    // bcrypt hash
  email          String    // For user creation on login
  displayName    String    // e.g., "Tradeblock"
  isActive       Boolean   @default(true)
  failedAttempts Int       @default(0)  // Rate limiting
  lockedUntil    DateTime? // Account lockout
  createdAt      DateTime  @default(now())
  updatedAt      DateTime  @updatedAt

  @@map("client_credentials")
}

// OAuth clients (applications that can authenticate via OAuth)
model OAuthClient {
  id            String   @id @default(cuid())
  clientId      String   @unique  // e.g., "better-contacts"
  clientSecret  String   // bcrypt hashed
  clientName    String   // e.g., "Better Contacts"
  redirectUris  String[] // Allowed callback URLs
  grantTypes    String[] // ["authorization_code", "refresh_token"]
  scope         String   // Space-separated allowed scopes
  isFirstParty  Boolean  @default(false)  // Skip consent for internal apps
  isActive      Boolean  @default(true)
  createdAt     DateTime @default(now())
  updatedAt     DateTime @updatedAt

  authCodes     OAuthAuthorizationCode[]
  accessTokens  OAuthAccessToken[]
  refreshTokens OAuthRefreshToken[]
  consents      OAuthUserConsent[]

  @@map("oauth_clients")
}

// Authorization codes (short-lived, single-use)
model OAuthAuthorizationCode {
  code                String   @id
  clientId            String
  userId              String
  redirectUri         String
  scope               String
  expiresAt           DateTime
  codeChallenge       String?  // PKCE
  codeChallengeMethod String?  // "S256"
  createdAt           DateTime @default(now())

  client OAuthClient @relation(fields: [clientId], references: [clientId], onDelete: Cascade)

  @@index([expiresAt])
  @@map("oauth_authorization_codes")
}

// Access tokens (for revocation lookup if needed - JWTs are self-validating)
model OAuthAccessToken {
  id          String   @id @default(cuid())
  tokenHash   String   @unique  // SHA-256 hash (faster than bcrypt for lookup)
  clientId    String
  userId      String?  // Null for client_credentials grant
  scope       String
  expiresAt   DateTime
  createdAt   DateTime @default(now())

  client OAuthClient @relation(fields: [clientId], references: [clientId], onDelete: Cascade)

  @@index([expiresAt])
  @@index([userId])
  @@map("oauth_access_tokens")
}

// Refresh tokens (with rotation support and reuse detection)
model OAuthRefreshToken {
  id            String   @id @default(cuid())
  tokenHash     String   @unique  // bcrypt hash
  clientId      String
  userId        String
  scope         String
  expiresAt     DateTime
  revoked       Boolean  @default(false)
  replacedBy    String?  // Token rotation tracking
  tokenFamilyId String   // Reuse detection
  createdAt     DateTime @default(now())

  client OAuthClient @relation(fields: [clientId], references: [clientId], onDelete: Cascade)

  @@index([expiresAt])
  @@index([tokenFamilyId])
  @@map("oauth_refresh_tokens")
}

// User consent records (for third-party OAuth apps)
model OAuthUserConsent {
  id        String    @id @default(cuid())
  userId    String
  clientId  String
  scope     String
  grantedAt DateTime  @default(now())
  expiresAt DateTime? // Null for permanent consent

  client OAuthClient @relation(fields: [clientId], references: [clientId], onDelete: Cascade)

  @@unique([userId, clientId])
  @@map("oauth_user_consents")
}

// ============================================================================
// CLARITY COMPANION API — Context Delivery for External Products
// ============================================================================

// Cached synthesis for cross-product use
model CompanionSynthesis {
  id            String   @id @default(cuid())
  userId        String   @unique

  // Base synthesis (structured JSON matching BaseSynthesis interface)
  baseSynthesis Json     // ~800 tokens of structured summary

  // Metadata
  profileHash   String   // Hash of source profile data for invalidation
  tokenCount    Int      // Actual token count
  version       String   // For cache invalidation (e.g., "v1.2.3")

  // Timestamps
  generatedAt   DateTime @default(now())
  expiresAt     DateTime // Synthesis TTL (24 hours default)

  // Relations
  user          User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId])
  @@index([expiresAt])
  @@map("companion_syntheses")
}

// Track what products have fetched (for analytics)
model CompanionAccessLog {
  id          String   @id @default(cuid())
  userId      String
  productId   String   // OAuth client ID (e.g., "better-contacts")
  endpoint    String   // Which endpoint was called
  section     String?  // If section fetch, which section
  tokenCount  Int      // Tokens returned
  cacheHit    Boolean  // Was synthesis cached?
  latencyMs   Int      // Response time
  createdAt   DateTime @default(now())

  @@index([userId, createdAt])
  @@index([productId, createdAt])
  @@map("companion_access_logs")
}
